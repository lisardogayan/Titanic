---
title: "Practica 2."
author: 
- "Lisardo Gayán Tremps"
- "José Luis Melo"
date: '`r format(Sys.Date(),"%e %B, %Y")`'
output:
  html_document:
    highlight: default
    number_sections: no
    theme: cosmo
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    highlight: default
    number_sections: no
    toc: yes
    toc_depth: 3
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r  Librerias , include=FALSE, eval = TRUE}
library(knitr)
library(kableExtra)
library(ggplot2)
library(dplyr)
```


# 1 - Descripción del dataset. ¿Por qué es importante y qué pregunta/problema pretende responder?

El dataset de Titanic: Machine Learning from Disaster se registran los datos de los pasajeros del famoso trasatlántico y se utiliza para predecir los supervivientes. Los datos estan divididos en dos dataset, uno de test y otro entrenamiento, para la creación de modelos de predicción.

# 2 - Integración y selección de los datos de interés a analizar

Se importan los datos. Primero el dataset train.


```{r Importacion datos train}
datostrain <- read.csv("./data/train.csv", stringsAsFactors = FALSE, na.strings = c("NA", ""))
str(datostrain)
```

Se observa como consta de 891 muestras y 12 variables, entre ellas Survived.

Posteiormente el dataset test.

```{r Importacion datos test}
datostest <- read.csv ("./data/test.csv", stringsAsFactors = FALSE, na.strings = c("NA", ""))
str(datostest)
```

Se observa como tiene 418 muestra, y 11 variables. La variable Survived no aparece porque es la que se tiene que predecir.
 
A continuacion, a la hora de fusionar los datos caben dos posibilidades, asignar "NA" a la variable datostest$Survived o no considerar los datos de survived en train. Se importan, fusionan los datos y se revisa la estructura inicial de los datos.  

```{r Unión datos}

datostest$Survived <- NA
datos <- rbind(datostrain, datostest)
str(datos)
```

A continuación comprobamos los datos que faltan

```{r Check valores faltantes}
# Busco primero qué variables tienen valores perdidos
missing_numbers <- sapply(datos, function(x) {sum(is.na(x))})
kable(data.frame(Variables = names(missing_numbers), Datos_faltantes= as.vector(missing_numbers))) %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

Podemos observar, que en Survived, salen los 418, que tenemos que predecir, por lo que todos los valores de train están informados.

A continuación se detallan las variables y su tipo inicial, este último, se modificara para su mejor analisis. 


```{r Prescindimos de survived}

# datostrain1 <- datostrain[,-2]
# data <- rbind(datostrain1, datostest) # Fusion datasets
data <- datos[,-2]
str(data)
```

```{r Tipos de Variables Original}
tipos <- sapply(data, class)
kable(data.frame(Variables = names(tipos), Tipo_Variable= as.vector(tipos))) %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```
Las variables, que no tienen datos faltantes, class y sex, se convertiran a factor. La variable cabin tiene muchos datos faltantes, así que en un primer momento no se utilizará. 

```{r Conversion Variables}
#data$Age <- as.integer(data$Age)
data$Pclass <- as.factor(data$Pclass)
data$Sex <- as.factor(data$Sex)
#data$Embarked <- as.factor(data$Embarked)
#data$Cabin <- as.factor(data$Cabin)

tipos_new <- sapply(data, class)
kable(data.frame(Variables = names(tipos_new), Tipo_Variable= as.vector(tipos_new))) %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

Una vez modificadas los tipos de valores se resume que:

```{r Resumen Variables}
summary(data)
```

PassengerId: Variable de tipo entero que contiene el id del pasajero, no existen valores nulos o perdidos.  
Pclass: Variable de tipo factor con la categoria asignada al pasajero, no existen valores nulos o perdidos.  
Name: Variable de tipo texto con el nombre del pasajero, no existen valores nulos o perdidos.  
Sex: Variable de tipo factor con el genero del pasajero (másculino, femenino), no existen valores nulos o perdidos.  
Age: Variable de tipo numérico que especifica la edad del pasajero, **existen 263 valores nulos.**  
SibSp: Variable de tipo entero que especifica el numero de hermanos/esposa abordo, no existen valores nulos o perdidos.  
Parch: Variable de tipo entero que especifica el numero de padres/hijos abordo, no existen valores nulos o perdidos.  
Ticket: Variable de tipo texto que indica el numero de ticket, no existen valores nulos o perdidos.   
Fare: Variable de tipo numero que especifica la tarifa pagada, **existe 1 valor nulo.**   
Cabin: Variable de tipo factor donde se especifica la cabina asignada, **existen 1014 valores perdidos.**   
Embarked: Variable de tipo factor que indica el puerto de embarque, **existen 2 valores perdidos.**    
  
# 3 - Limpieza de datos

## 3.1. ¿Los datos contienen ceros o elementos vacíos? ¿Cómo gestionarías cada uno de estos casos?

Volvemos a mostrar los datos que contienen ceros o elementos vacíos.


```{r Check valores faltantes bis}
# Busco primero qué variables tienen valores perdidos
missing_numbers <- sapply(datos, function(x) {sum(is.na(x))})
kable(data.frame(Variables = names(missing_numbers), Datos_faltantes= as.vector(missing_numbers))) %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```
  

De las variables existentes a continuación se espedifican aquellas que contienen valores perdido o nulos.  

- Age: *existen 263 valores nulos.*  

Para imputar valores de **edad**, hay varias opciones desde la más sencilla que sería asignar la media a otras opciones como la propuesta en 
http://jstatsoft.org/article/view/v045i03 Data Analysis with R,  A comprehensive guide to manipulating, analyzing and visualizing data in R
Pag 373 - 386 

Se puede analizar si es mejor imputar por la media, mediana u otro método (rpart o mice)

- Fare: *existe 1 valor nulo.*     
Para imputar valores **Fare**  
Dado que unicamente hay un valor perdido, es posible imputarlo por la media o la mediana en base al puerto de embarque "S" y la clase "3"

```{r Confirmación nulos Fare}
data[is.na(data$Fare),]
M_fare<- subset(data,data$Pclass == '3' & data$Embarked == 'S')
mean(M_fare$Fare, na.rm = T)
median(M_fare$Fare, na.rm = T)

``` 
```{r Plot nulos Fare}
ggplot(M_fare,  aes(x = Fare)) +
  geom_density(fill = 'grey', alpha=0.4) + 
  geom_vline(aes(xintercept=median(Fare, na.rm=T)),
    colour='blue', linetype='dashed', lwd=1) +
  geom_vline(aes(xintercept=mean(Fare, na.rm=T)),
  colour='red', linetype='dashed', lwd=1)
``` 
Observamos como al realizar la gráfica nos dice que hay un valor nulo.

La tarifa de 8.05 coincide con la mediana de los pasajeros de tercera clase que embarcaron en S, por lo que se podría imputar este valor. 

```{r Imputacion Fare}
data$Fare[c(1044)] <- 8.05
data[1044,]
```

Volviendo a representar

```{r Plot nulos Fare 2}
M_fare<- subset(data,data$Pclass == '3' & data$Embarked == 'S')
ggplot(M_fare,  aes(x = Fare)) +
  geom_density(fill = 'grey', alpha=0.4) + 
  geom_vline(aes(xintercept=median(Fare, na.rm=T)),
    colour='blue', linetype='dashed', lwd=1) +
  geom_vline(aes(xintercept=mean(Fare, na.rm=T)),
  colour='red', linetype='dashed', lwd=1)
``` 

Ahora ya no sale que haya un valor nulo en fare.

- Cabin: *existen 1014 valores perdidos.*     
Para imputar valores **Cabin**  
Esta variable tiene muchos valores perdidos, se podria conseguir predecir la cubierta asignada al pasajero pero es un dato que poco beneficio podría traer ya que se puede realizar el analisis con la combinación entre la tarifa y la clase del pasajero.  


- Embarked: *existen 2 valores perdidos.*      
Para imputar valores **Embarked**  

Mostramos los valores perdidos

```{r}
data[is.na(data$Embarked),]

```

Al ser unicamente dos valores perdidos, se podría sustituir los valores por la media, en base a otros pasajeros de la misma clase y tarifa (Fare). 
Los pasajeros han pagado una tarifa de 80 y pertenecian a primera clase. 

```{r Plot nulos embarked}
embarked_pass_1 <- data %>%
  filter(PassengerId != 62 & PassengerId != 830 & Pclass == 1)
ggplot(embarked_pass_1, aes(x = Embarked, y = Fare, fill = factor(Pclass))) +
  geom_boxplot() +
  geom_hline(aes(yintercept=80), 
    colour='blue', linetype='dashed', lwd=1) 

```
La tarifa de 80 coincide con la media de los pasajeros de primera clase que embarcaron en C, por lo que se podría imputar este puerto. 

```{r Imputacion Embarco}
data$Embarked[c(62, 830)] <- 'C'
```

Otra opción, sería considerar también el sexo, ya que principios del siglo XX, no se caracterizaba por una igualdad de hombres y mujeres.

```{r Plot nulos embarked considerando sexo}
embarked_pass_2 <- data %>%
  filter(PassengerId != 62 & PassengerId != 830 & Pclass == 1 & Sex == "female")
ggplot(embarked_pass_2, aes(x = Embarked, y = Fare, fill = factor(Pclass))) +
  geom_boxplot() +
  geom_hline(aes(yintercept=80), 
    colour='blue', linetype='dashed', lwd=1) 

```

En este caso cualquiera de los 3 puertos tendría una media cercana a 80. Como no creemos que el puerto de embarque este correlacionado con la supervivencia, podemos dejar "C"

## 3.2. Identificación y tratamiento de valores extremos. 

Los valores extremos tendrían sentido en los campos Fare y Age
  
```{r Valores Extremos}
# Referencia:
# https://www.r-bloggers.com/identify-describe-plot-and-remove-the-outliers-from-the-dataset/
outlierKD <- function(dt, var) {
     var_name <- eval(substitute(var),eval(dt))
     na1 <- sum(is.na(var_name))
     m1 <- mean(var_name, na.rm = T)
     par(mfrow=c(2, 2), oma=c(0,0,3,0))
     boxplot(var_name, main="With outliers")
     hist(var_name, main="With outliers", xlab=NA, ylab=NA)
     outlier <- boxplot.stats(var_name)$out
     mo <- mean(outlier)
     var_name <- ifelse(var_name %in% outlier, NA, var_name)
     boxplot(var_name, main="Without outliers")
     hist(var_name, main="Without outliers", xlab=NA, ylab=NA)
     title("Outlier Check", outer=TRUE)
     na2 <- sum(is.na(var_name))
     cat("Outliers identified:", na2 - na1, "n")
     cat("Propotion (%) of outliers:", round((na2 - na1) / sum(!is.na(var_name))*100, 1), "n")
     cat("Mean of the outliers:", round(mo, 2), "n")
     m2 <- mean(var_name, na.rm = T)
     cat("Mean without removing outliers:", round(m1, 2), "n")
     cat("Mean if we remove outliers:", round(m2, 2), "n")
     response <- readline(prompt="Do you want to remove outliers and to replace with NA? [yes/no]: ")
     if(response == "y" | response == "yes"){
          dt[as.character(substitute(var))] <- invisible(var_name)
          assign(as.character(as.list(match.call())$dt), dt, envir = .GlobalEnv)
          cat("Outliers successfully removed", "n")
          return(invisible(dt))
     } else{
          cat("Nothing changed", "n")
          return(invisible(var_name))
     }
}
```


```{r Outlier 1}
outlierKD(data, Age)


```

```{r Outlier 2}
outlierKD(data, Fare)


```

Como es perfectamente aceptable las edades y que haya gente que pagara mucho más por su billete, al ser el primer viaje del transatlántico más grande de la epoca, no se cambia ningún valor

# 4. Análisis de los datos.

## 4.1. Selección de los grupos de datos que se quieren analizar/comparar (planificación de los análisis a aplicar)


## 4.2. Comprobación de la normalidad y homogeneidad de la varianza.


## 4.3. Aplicación de pruebas estadísticas para comprar los grupos de datos. En función de los datos y el objetivo del estudio, aplicar pruebas de contraste de hipótesis, correlaciones, regresiones, etc. Aplicar al menos tres métodos de análisis diferentes.


# 5. Representación de los reultados a apartir de tablas y gráficas.


# 6. Resolución del problema. A partir de los resultados obtenidos. ¿cuáles son las conclusiones?. ¿Los resultados permiten responder al problemas?


# 7. Código. Hay que adjuntar el código, preferiblemente en R, con el que se ha realizado la limpieza, análisis y represntación de los datos.